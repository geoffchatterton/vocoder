<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>128-Bin Modulator / 64-Band Vocoder</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .file-upload {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .file-upload:hover {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }
        
        .file-upload input[type="file"] {
            display: none;
        }
        
        .file-upload label {
            cursor: pointer;
            display: block;
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            transition: background 0.3s ease;
        }
        
        .file-upload label:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .control-group input, .control-group select {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            box-sizing: border-box;
        }
        
        .control-group input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }
        
        .control-value {
            display: inline-block;
            margin-left: 5px;
            font-weight: normal;
            opacity: 0.9;
        }
        
        .control-group.highlight {
            background: rgba(255, 200, 100, 0.15);
            border: 1px solid rgba(255, 200, 100, 0.3);
        }
        
        .buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }
        
        button {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        button:disabled {
            background: rgba(255, 255, 255, 0.3);
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .visualizer-container {
            margin-top: 20px;
        }
        
        .visualizer-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        
        .visualizer {
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 10px;
            position: relative;
            overflow: hidden;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }
        
        .filename {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
        }
        
        .info-text {
            font-size: 0.8em;
            opacity: 0.7;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>128-Bin Modulator / 64-Band Vocoder</h1>
        <div class="subtitle">High-resolution modulator analysis with selective frequency mapping</div>
        
        <div class="upload-section">
            <div class="file-upload">
                <label for="carrierFile">
                    ðŸŽµ Upload Carrier File
                    <div class="filename" id="carrierFilename">No file selected</div>
                </label>
                <input type="file" id="carrierFile" accept="audio/*">
            </div>
            
            <div class="file-upload">
                <label for="modulatorFile">
                    ðŸŽ¤ Upload Modulator File
                    <div class="filename" id="modulatorFilename">No file selected</div>
                </label>
                <input type="file" id="modulatorFile" accept="audio/*">
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group highlight">
                <label for="modulatorStartBin">
                    Modulator Start Bin (0-64)
                    <span class="control-value" id="startBinValue">0</span>
                </label>
                <input type="range" id="modulatorStartBin" min="0" max="64" value="0">
                <div class="info-text">Selects which 64 of 128 modulator bins to use</div>
            </div>
            
            <div class="control-group">
                <label for="bandOffset">
                    Band Offset (0-64)
                    <span class="control-value" id="offsetValue">0</span>
                </label>
                <input type="range" id="bandOffset" min="0" max="64" value="0">
                <div class="info-text">Shifts modulator-to-carrier mapping</div>
            </div>
            
            <div class="control-group">
                <label for="mixLevel">
                    Mix Level
                    <span class="control-value" id="mixValue">1.00</span>
                </label>
                <input type="range" id="mixLevel" min="0" max="1" step="0.01" value="1">
            </div>
            
            <div class="control-group">
                <label for="modulatorMix">
                    Modulator Mix
                    <span class="control-value" id="modMixValue">0.00</span>
                </label>
                <input type="range" id="modulatorMix" min="0" max="0.5" step="0.01" value="0">
            </div>
            
            <div class="control-group">
                <label for="outputGain">
                    Output Gain
                    <span class="control-value" id="gainValue">0.50</span>
                </label>
                <input type="range" id="outputGain" min="0" max="2" step="0.01" value="0.5">
            </div>
        </div>
        
        <div class="buttons">
            <button id="playBtn" disabled>â–¶ Play Vocoder</button>
            <button id="stopBtn" disabled>â–  Stop</button>
        </div>
        
        <div class="status" id="status">Upload carrier and modulator files to begin</div>
        
        <div class="visualizer-container">
            <div class="visualizer-label">Modulator Analysis (128 bins, using bins <span id="binRangeDisplay">0-63</span>)</div>
            <div class="visualizer">
                <canvas id="modulatorVisualizer"></canvas>
            </div>
            
            <div class="visualizer-label">Output Spectrum (64 bands)</div>
            <div class="visualizer">
                <canvas id="outputVisualizer"></canvas>
            </div>
        </div>
    </div>

    <script>
        class Vocoder {
            constructor() {
                this.audioContext = null;
                this.carrierBuffer = null;
                this.modulatorBuffer = null;
                this.carrierSource = null;
                this.modulatorSource = null;
                this.outputAnalyser = null;
                this.isPlaying = false;
                this.modulatorStartBin = 0;
                this.bandOffset = 0;
                this.mixLevel = 1;
                this.outputGain = 0.5;
                this.modulatorMix = 0;
                
                this.setupEventListeners();
                this.setupVisualizers();
            }
            
            async initAudioContext() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                }
            }
            
            setupEventListeners() {
                document.getElementById('carrierFile').addEventListener('change', (e) => {
                    this.loadAudioFile(e.target.files[0], 'carrier');
                });
                
                document.getElementById('modulatorFile').addEventListener('change', (e) => {
                    this.loadAudioFile(e.target.files[0], 'modulator');
                });
                
                document.getElementById('playBtn').addEventListener('click', () => {
                    this.play();
                });
                
                document.getElementById('stopBtn').addEventListener('click', () => {
                    this.stop();
                });
                
                document.getElementById('modulatorStartBin').addEventListener('input', (e) => {
                    this.modulatorStartBin = parseInt(e.target.value);
                    document.getElementById('startBinValue').textContent = this.modulatorStartBin;
                    document.getElementById('binRangeDisplay').textContent = 
                        `${this.modulatorStartBin}-${this.modulatorStartBin + 63}`;
                });
                
                document.getElementById('bandOffset').addEventListener('input', (e) => {
                    this.bandOffset = parseInt(e.target.value);
                    document.getElementById('offsetValue').textContent = this.bandOffset;
                });
                
                document.getElementById('mixLevel').addEventListener('input', (e) => {
                    this.mixLevel = parseFloat(e.target.value);
                    document.getElementById('mixValue').textContent = this.mixLevel.toFixed(2);
                });
                
                document.getElementById('modulatorMix').addEventListener('input', (e) => {
                    this.modulatorMix = parseFloat(e.target.value);
                    document.getElementById('modMixValue').textContent = this.modulatorMix.toFixed(2);
                    if (this.modulatorGain) {
                        this.modulatorGain.gain.value = this.modulatorMix;
                    }
                });
                
                document.getElementById('outputGain').addEventListener('input', (e) => {
                    this.outputGain = parseFloat(e.target.value);
                    document.getElementById('gainValue').textContent = this.outputGain.toFixed(2);
                    if (this.gainNode) {
                        this.gainNode.gain.value = this.outputGain;
                    }
                });
            }
            
            async loadAudioFile(file, type) {
                if (!file) return;
                
                await this.initAudioContext();
                
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                
                if (type === 'carrier') {
                    this.carrierBuffer = audioBuffer;
                    document.getElementById('carrierFilename').textContent = file.name;
                } else if (type === 'modulator') {
                    this.modulatorBuffer = audioBuffer;
                    document.getElementById('modulatorFilename').textContent = file.name;
                }
                
                this.updateStatus();
                this.updatePlayButton();
            }
            
            updateStatus() {
                const status = document.getElementById('status');
                if (this.carrierBuffer && this.modulatorBuffer) {
                    status.textContent = 'Ready to play vocoder';
                } else if (this.carrierBuffer) {
                    status.textContent = 'Carrier loaded - upload modulator file';
                } else if (this.modulatorBuffer) {
                    status.textContent = 'Modulator loaded - upload carrier file';
                } else {
                    status.textContent = 'Upload carrier and modulator files to begin';
                }
            }
            
            updatePlayButton() {
                const playBtn = document.getElementById('playBtn');
                playBtn.disabled = !(this.carrierBuffer && this.modulatorBuffer);
            }
            
            async play() {
                if (this.isPlaying) return;
                
                await this.initAudioContext();
                this.createVocoderChain();
                
                this.isPlaying = true;
                document.getElementById('playBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('status').textContent = 'Playing vocoder...';
            }
            
            createVocoderChain() {
                // Create sources
                this.carrierSource = this.audioContext.createBufferSource();
                this.modulatorSource = this.audioContext.createBufferSource();
                this.carrierSource.buffer = this.carrierBuffer;
                this.modulatorSource.buffer = this.modulatorBuffer;
                this.carrierSource.loop = true;
                
                // Create main output gain and analyzer
                this.gainNode = this.audioContext.createGain();
                this.gainNode.gain.value = this.outputGain;
                this.outputAnalyser = this.audioContext.createAnalyser();
                this.outputAnalyser.fftSize = 256;
                
                // Create HIGH RESOLUTION analyzer for modulator (128 bins)
                const modulatorAnalyzer = this.audioContext.createAnalyser();
                modulatorAnalyzer.fftSize = 1024; // Higher FFT size for 128 useful bins
                modulatorAnalyzer.smoothingTimeConstant = 0.3;
                modulatorAnalyzer.minDecibels = -60;
                modulatorAnalyzer.maxDecibels = -10;
                
                // Store for visualization
                this.modulatorAnalyzer = modulatorAnalyzer;
                
                // Connect modulator to its analyzer
                this.modulatorSource.connect(modulatorAnalyzer);
                
                // Create controllable modulator mix path
                this.modulatorGain = this.audioContext.createGain();
                this.modulatorGain.gain.value = this.modulatorMix;
                this.modulatorSource.connect(this.modulatorGain);
                
                // Create gain nodes for each frequency band (64 carrier bands)
                this.bandGains = [];
                const mixNode = this.audioContext.createGain();
                mixNode.gain.value = 0.7;
                
                // Create 64-band vocoder for carrier
                const numCarrierBands = 64;
                const filters = [];
                
                // Frequency range for carrier: 80Hz to 8000Hz (logarithmic spacing)
                const minFreq = 80;
                const maxFreq = 8000;
                
                for (let i = 0; i < numCarrierBands; i++) {
                    // Logarithmic frequency distribution
                    const logMin = Math.log(minFreq);
                    const logMax = Math.log(maxFreq);
                    const freqRatio = i / (numCarrierBands - 1);
                    const centerFreq = Math.exp(logMin + freqRatio * (logMax - logMin));
                    const bandwidth = centerFreq * 0.25;
                    
                    const lowFreq = Math.max(centerFreq - bandwidth / 2, 20);
                    const highFreq = Math.min(centerFreq + bandwidth / 2, this.audioContext.sampleRate / 2);
                    
                    // Create bandpass filter for carrier
                    const highpass = this.audioContext.createBiquadFilter();
                    highpass.type = 'highpass';
                    highpass.frequency.value = lowFreq;
                    highpass.Q.value = 0.7;
                    
                    const lowpass = this.audioContext.createBiquadFilter();
                    lowpass.type = 'lowpass';
                    lowpass.frequency.value = highFreq;
                    lowpass.Q.value = 0.7;
                    
                    // Chain filters
                    highpass.connect(lowpass);
                    
                    // Create gain node controlled by modulator
                    const bandGain = this.audioContext.createGain();
                    bandGain.gain.value = 0;
                    
                    // Connect carrier through filter and gain
                    this.carrierSource.connect(highpass);
                    lowpass.connect(bandGain);
                    bandGain.connect(mixNode);
                    
                    this.bandGains.push(bandGain);
                    filters.push({highpass, lowpass, centerFreq});
                }
                
                // Connect the controllable modulator mix to the output
                this.modulatorGain.connect(mixNode);
                
                // Connect output chain
                mixNode.connect(this.gainNode);
                this.gainNode.connect(this.outputAnalyser);
                this.outputAnalyser.connect(this.audioContext.destination);
                
                // Start sources
                this.carrierSource.start();
                this.modulatorSource.start();
                
                // Enhanced envelope following with 128-bin modulator analysis
                const updateEnvelopes = () => {
                    if (!this.isPlaying) return;
                    
                    // Get 128 bins of frequency data from modulator
                    const freqData = new Uint8Array(128);
                    const fullFreqData = new Uint8Array(modulatorAnalyzer.frequencyBinCount);
                    modulatorAnalyzer.getByteFrequencyData(fullFreqData);
                    
                    // Extract the first 128 bins (covers the most relevant frequency range)
                    for (let i = 0; i < 128; i++) {
                        freqData[i] = fullFreqData[i];
                    }
                    
                    // Calculate overall signal level for noise gate
                    let totalLevel = 0;
                    for (let i = 0; i < freqData.length; i++) {
                        totalLevel += freqData[i];
                    }
                    totalLevel = totalLevel / freqData.length / 255;
                    
                    // Noise gate threshold
                    const noiseGate = totalLevel > 0.05 ? 1 : Math.max(totalLevel * 20, 0.1);
                    
                    // Map 64 consecutive modulator bins (starting from modulatorStartBin) to 64 carrier bands
                    for (let i = 0; i < numCarrierBands && i < this.bandGains.length; i++) {
                        // Get the modulator bin index (from the selected 64-bin window)
                        const modulatorBin = this.modulatorStartBin + i;
                        
                        if (modulatorBin < 128) {
                            // Get the level from the specific modulator bin
                            const bandLevel = freqData[modulatorBin] / 255;
                            
                            // Apply band offset mapping: modulator bin i controls carrier band (i + offset) % numCarrierBands
                            const targetBand = (i + this.bandOffset) % numCarrierBands;
                            
                            if (targetBand < this.bandGains.length) {
                                // Enhanced envelope shaping
                                let targetGain = bandLevel;
                                
                                // Compress dynamics
                                targetGain = Math.pow(targetGain, 0.6);
                                
                                // Apply noise gate
                                targetGain *= noiseGate;
                                
                                // Scale and apply mix level
                                targetGain = targetGain * this.mixLevel * 1.2;
                                
                                // Limit maximum gain
                                targetGain = Math.min(targetGain, 1.0);
                                
                                // Faster response for transients
                                const rampTime = bandLevel > this.bandGains[targetBand].gain.value ? 0.005 : 0.015;
                                
                                this.bandGains[targetBand].gain.linearRampToValueAtTime(
                                    targetGain,
                                    this.audioContext.currentTime + rampTime
                                );
                            }
                        }
                    }
                    
                    setTimeout(updateEnvelopes, 10);
                };
                
                // Start envelope following
                setTimeout(updateEnvelopes, 100);
                
                // Handle modulator end
                this.modulatorSource.onended = () => {
                    if (this.isPlaying) this.restartModulator();
                };
                
                // Store references
                this.mixNode = mixNode;
                this.filters = filters;
                
                console.log(`Created vocoder with 128-bin modulator analysis and 64 carrier bands`);
                console.log(`Using modulator bins ${this.modulatorStartBin} to ${this.modulatorStartBin + 63}`);
                console.log(`Frequency range: ${minFreq}Hz - ${maxFreq}Hz`);
            }
            
            restartModulator() {
                const newModulator = this.audioContext.createBufferSource();
                newModulator.buffer = this.modulatorBuffer;
                newModulator.connect(this.modulatorAnalyzer);
                newModulator.connect(this.modulatorGain);
                newModulator.start();
                newModulator.onended = () => {
                    if (this.isPlaying) this.restartModulator();
                };
                this.modulatorSource = newModulator;
            }
            
            stop() {
                if (!this.isPlaying) return;
                
                if (this.carrierSource) {
                    this.carrierSource.stop();
                    this.carrierSource = null;
                }
                
                if (this.modulatorSource) {
                    this.modulatorSource.stop();
                    this.modulatorSource = null;
                }
                
                if (this.mixNode) {
                    this.mixNode.disconnect();
                    this.mixNode = null;
                }
                
                if (this.bandGains) {
                    this.bandGains.forEach(gain => gain.disconnect());
                    this.bandGains = null;
                }
                
                if (this.filters) {
                    this.filters.forEach(filter => {
                        filter.highpass.disconnect();
                        filter.lowpass.disconnect();
                    });
                    this.filters = null;
                }
                
                this.isPlaying = false;
                document.getElementById('playBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('status').textContent = 'Stopped';
            }
            
            setupVisualizers() {
                this.modCanvas = document.getElementById('modulatorVisualizer');
                this.modCanvasCtx = this.modCanvas.getContext('2d');
                this.outCanvas = document.getElementById('outputVisualizer');
                this.outCanvasCtx = this.outCanvas.getContext('2d');
                
                const resizeCanvas = () => {
                    this.modCanvas.width = this.modCanvas.clientWidth;
                    this.modCanvas.height = this.modCanvas.clientHeight;
                    this.outCanvas.width = this.outCanvas.clientWidth;
                    this.outCanvas.height = this.outCanvas.clientHeight;
                };
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                this.draw();
            }
            
            draw() {
                requestAnimationFrame(() => this.draw());
                
                // Draw modulator spectrum (128 bins)
                if (!this.modulatorAnalyzer) {
                    this.modCanvasCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    this.modCanvasCtx.fillRect(0, 0, this.modCanvas.width, this.modCanvas.height);
                } else {
                    const dataArray = new Uint8Array(128);
                    const fullData = new Uint8Array(this.modulatorAnalyzer.frequencyBinCount);
                    this.modulatorAnalyzer.getByteFrequencyData(fullData);
                    
                    // Extract first 128 bins
                    for (let i = 0; i < 128; i++) {
                        dataArray[i] = fullData[i];
                    }
                    
                    this.modCanvasCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    this.modCanvasCtx.fillRect(0, 0, this.modCanvas.width, this.modCanvas.height);
                    
                    const barWidth = this.modCanvas.width / 128;
                    let x = 0;
                    
                    for (let i = 0; i < 128; i++) {
                        const barHeight = (dataArray[i] / 255) * this.modCanvas.height;
                        
                        // Highlight the selected 64-bin range
                        const isSelected = i >= this.modulatorStartBin && i < this.modulatorStartBin + 64;
                        
                        if (isSelected) {
                            // Bright colors for selected range
                            const gradient = this.modCanvasCtx.createLinearGradient(0, this.modCanvas.height - barHeight, 0, this.modCanvas.height);
                            gradient.addColorStop(0, `hsl(${(i - this.modulatorStartBin) * 5.6}, 70%, 60%)`);
                            gradient.addColorStop(1, `hsl(${(i - this.modulatorStartBin) * 5.6}, 70%, 30%)`);
                            this.modCanvasCtx.fillStyle = gradient;
                        } else {
                            // Dim gray for non-selected bins
                            this.modCanvasCtx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                        }
                        
                        this.modCanvasCtx.fillRect(x, this.modCanvas.height - barHeight, barWidth - 1, barHeight);
                        x += barWidth;
                    }
                }
                
                // Draw output spectrum (64 bands)
                if (!this.outputAnalyser) {
                    this.outCanvasCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    this.outCanvasCtx.fillRect(0, 0, this.outCanvas.width, this.outCanvas.height);
                } else {
                    const bufferLength = this.outputAnalyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);
                    this.outputAnalyser.getByteFrequencyData(dataArray);
                    
                    this.outCanvasCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    this.outCanvasCtx.fillRect(0, 0, this.outCanvas.width, this.outCanvas.height);
                    
                    const barWidth = this.outCanvas.width / 64;
                    let x = 0;
                    
                    for (let i = 0; i < 64; i++) {
                        const barHeight = (dataArray[i] / 255) * this.outCanvas.height;
                        
                        const gradient = this.outCanvasCtx.createLinearGradient(0, this.outCanvas.height - barHeight, 0, this.outCanvas.height);
                        gradient.addColorStop(0, `hsl(${i * 5.6}, 70%, 60%)`);
                        gradient.addColorStop(1, `hsl(${i * 5.6}, 70%, 30%)`);
                        
                        this.outCanvasCtx.fillStyle = gradient;
                        this.outCanvasCtx.fillRect(x, this.outCanvas.height - barHeight, barWidth - 1, barHeight);
                        
                        x += barWidth;
                    }
                }
            }
        }
        
        // Initialize vocoder
        const vocoder = new Vocoder();
    </script>
</body>
</html>
